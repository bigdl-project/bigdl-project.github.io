<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nn package &#8212; PySpark master documentation</title>
    
    <link rel="stylesheet" href="static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'master',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="optim package" href="optim.html" />
    <link rel="prev" title="models.lenet package" href="models.lenet.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="optim.html" title="optim package"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="models.lenet.html" title="models.lenet package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PySpark master documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">nn package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-nn.criterion">nn.criterion module</a></li>
<li><a class="reference internal" href="#module-nn.layer">nn.layer module</a></li>
<li><a class="reference internal" href="#module-nn">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="models.lenet.html"
                        title="previous chapter">models.lenet package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="optim.html"
                        title="next chapter">optim package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="sources/nn.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nn-package">
<h1>nn package<a class="headerlink" href="#nn-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nn.criterion">
<span id="nn-criterion-module"></span><h2>nn.criterion module<a class="headerlink" href="#module-nn.criterion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nn.criterion.AbsCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">AbsCriterion</code><span class="sig-paren">(</span><em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#AbsCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.AbsCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>measures the mean absolute value of the element-wise difference between input</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">absCriterion</span> <span class="o">=</span> <span class="n">AbsCriterion</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createAbsCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.BCECriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">BCECriterion</code><span class="sig-paren">(</span><em>weights=None</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#BCECriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.BCECriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the Binary Cross Entropy
between the target and the output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>weights</strong> &#8211; weights for each class</li>
<li><strong>sizeAverage</strong> &#8211; whether to average the loss or not</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bCECriterion</span> <span class="o">=</span> <span class="n">BCECriterion</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="go">creating: createBCECriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bCECriterion</span> <span class="o">=</span> <span class="n">BCECriterion</span><span class="p">()</span>
<span class="go">creating: createBCECriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.ClassNLLCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">ClassNLLCriterion</code><span class="sig-paren">(</span><em>weights=None</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#ClassNLLCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.ClassNLLCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>The negative log likelihood criterion.
It is useful to train a classification problem with n classes.
If provided, the optional argument weights should be a 1D Tensor
assigning weight to each of the classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>weights</strong> &#8211; weights of each class</li>
<li><strong>size_average</strong> &#8211; whether to average or not</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classNLLCriterion</span> <span class="o">=</span> <span class="n">ClassNLLCriterion</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createClassNLLCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classNLLCriterion</span> <span class="o">=</span> <span class="n">ClassNLLCriterion</span><span class="p">()</span>
<span class="go">creating: createClassNLLCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.ClassSimplexCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">ClassSimplexCriterion</code><span class="sig-paren">(</span><em>n_classes</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#ClassSimplexCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.ClassSimplexCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>ClassSimplexCriterion implements a criterion for classification.
It learns an embedding per class, where each class&#8217; embedding is a
point on an (N-1)-dimensional simplex, where N is the number of classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nClasses</strong> &#8211; the number of classes.</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">classSimplexCriterion</span> <span class="o">=</span> <span class="n">ClassSimplexCriterion</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating: createClassSimplexCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.CosineEmbeddingCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">CosineEmbeddingCriterion</code><span class="sig-paren">(</span><em>margin=0.0</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#CosineEmbeddingCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.CosineEmbeddingCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the loss given an input x = {x1, x2},
a table of two Tensors, and a Tensor label y with values 1 or -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>margin</strong> &#8211; a number from -1 to 1, 0 to 0.5 is suggested</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cosineEmbeddingCriterion</span> <span class="o">=</span> <span class="n">CosineEmbeddingCriterion</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createCosineEmbeddingCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.Criterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">Criterion</code><span class="sig-paren">(</span><em>jvalue</em>, <em>bigdl_type</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#Criterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.Criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="util.html#util.common.JavaValue" title="util.common.JavaValue"><code class="xref py py-class docutils literal"><span class="pre">util.common.JavaValue</span></code></a></p>
<p>Criterion is helpful to train a neural network.
Given an input and a target, they compute a gradient according to a given loss function.</p>
<dl class="classmethod">
<dt id="nn.criterion.Criterion.of">
<em class="property">classmethod </em><code class="descname">of</code><span class="sig-paren">(</span><em>jcriterion</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#Criterion.of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.Criterion.of" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a python Criterion by a java criterion object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>jcriterion</strong> &#8211; A java criterion object which created by Py4j</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a criterion.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nn.criterion.CrossEntropyCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">CrossEntropyCriterion</code><span class="sig-paren">(</span><em>weights=None</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#CrossEntropyCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.CrossEntropyCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>This criterion combines LogSoftMax and ClassNLLCriterion in one single class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>weights</strong> &#8211; A tensor assigning weight to each of the classes</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cec</span> <span class="o">=</span> <span class="n">CrossEntropyCriterion</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="go">creating: createCrossEntropyCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cec</span> <span class="o">=</span> <span class="n">CrossEntropyCriterion</span><span class="p">()</span>
<span class="go">creating: createCrossEntropyCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.DistKLDivCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">DistKLDivCriterion</code><span class="sig-paren">(</span><em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#DistKLDivCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.DistKLDivCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>The Kullback-Leibler divergence criterion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sizeAverage</strong> &#8211; </td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distKLDivCriterion</span> <span class="o">=</span> <span class="n">DistKLDivCriterion</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createDistKLDivCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.HingeEmbeddingCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">HingeEmbeddingCriterion</code><span class="sig-paren">(</span><em>margin=1</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#HingeEmbeddingCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.HingeEmbeddingCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the loss given an
input x which is a 1-dimensional vector and a label y (1 or -1).
This is usually used for measuring whether two inputs are similar
or dissimilar,
e.g. using the L1 pairwise distance, and is typically used for
learning nonlinear embeddings or semi-supervised learning.</p>
<p>If x and y are n-dimensional Tensors, the sum operation still operates
over all the elements, and divides by n (this can be avoided if one sets
the internal variable sizeAverage to false). The margin has a default
value of 1, or can be set in the constructor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hingeEmbeddingCriterion</span> <span class="o">=</span> <span class="n">HingeEmbeddingCriterion</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createHingeEmbeddingCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.L1HingeEmbeddingCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">L1HingeEmbeddingCriterion</code><span class="sig-paren">(</span><em>margin=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#L1HingeEmbeddingCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.L1HingeEmbeddingCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the loss given an input x = {x1, x2},
a table of two Tensors, and a label y (1 or -1):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>margin</strong> &#8211; </td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l1HingeEmbeddingCriterion</span> <span class="o">=</span> <span class="n">L1HingeEmbeddingCriterion</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createL1HingeEmbeddingCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MSECriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MSECriterion</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MSECriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MSECriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the mean squared error between n elements
in the input x and output y:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span> \<span class="nb">sum</span> <span class="o">|</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">y_i</span><span class="o">|^</span><span class="mi">2</span>
</pre></div>
</div>
<p>If x and y are d-dimensional Tensors with a total of n elements,
the sum operation still operates over all the elements, and divides by n.
The two Tensors must have the same number of elements (but their sizes might be different).
The division by n can be avoided if one sets the internal variable sizeAverage to false.
By default, the losses are averaged over observations for each minibatch. However,
if the field sizeAverage is set to false, the losses are instead summed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mSECriterion</span> <span class="o">=</span> <span class="n">MSECriterion</span><span class="p">()</span>
<span class="go">creating: createMSECriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MarginCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MarginCriterion</code><span class="sig-paren">(</span><em>margin=1.0</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MarginCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MarginCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that optimizes a two-class classification hinge loss (margin-based loss)
between input x (a Tensor of dimension 1) and output y.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>margin</strong> &#8211; if unspecified, is by default 1.</li>
<li><strong>size_average</strong> &#8211; size average in a mini-batch</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">marginCriterion</span> <span class="o">=</span> <span class="n">MarginCriterion</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createMarginCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MarginRankingCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MarginRankingCriterion</code><span class="sig-paren">(</span><em>margin=1.0</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MarginRankingCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MarginRankingCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that measures the loss given an input x = {x1, x2},
a table of two Tensors of size 1 (they contain only scalars), and a label y (1 or -1).
In batch mode, x is a table of two Tensors of size batchsize, and y is a Tensor of size
batchsize containing 1 or -1 for each corresponding pair of elements in the input Tensor.
If y == 1 then it assumed the first input should be ranked higher (have a larger value) than
the second input, and vice-versa for y == -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>margin</strong> &#8211; </td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">marginRankingCriterion</span> <span class="o">=</span> <span class="n">MarginRankingCriterion</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createMarginRankingCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MultiCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MultiCriterion</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MultiCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MultiCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>a weighted sum of other criterions each applied to the same input and target</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">multiCriterion</span> <span class="o">=</span> <span class="n">MultiCriterion</span><span class="p">()</span>
<span class="go">creating: createMultiCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MultiLabelMarginCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MultiLabelMarginCriterion</code><span class="sig-paren">(</span><em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MultiLabelMarginCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MultiLabelMarginCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that optimizes a multi-class multi-classification hinge loss (
margin-based loss) between input x and output y (which is a Tensor of target class indices)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size_average</strong> &#8211; size average in a mini-batch</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">multiLabelMarginCriterion</span> <span class="o">=</span> <span class="n">MultiLabelMarginCriterion</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createMultiLabelMarginCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MultiLabelSoftMarginCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MultiLabelSoftMarginCriterion</code><span class="sig-paren">(</span><em>weights=None</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MultiLabelSoftMarginCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MultiLabelSoftMarginCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>A MultiLabel multiclass criterion based on sigmoid:
the loss is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">l</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_i</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">log</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>where p[i] = exp(x[i]) / (1 + exp(x[i]))
and with weights:
l(x,y) = - sum_i weights[i] (y[i] * log(p[i]) + (1 - y[i]) * log (1 - p[i]))</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiLabelSoftMarginCriterion</span> <span class="o">=</span> <span class="n">MultiLabelSoftMarginCriterion</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="go">creating: createMultiLabelSoftMarginCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiLabelSoftMarginCriterion</span> <span class="o">=</span> <span class="n">MultiLabelSoftMarginCriterion</span><span class="p">()</span>
<span class="go">creating: createMultiLabelSoftMarginCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.MultiMarginCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">MultiMarginCriterion</code><span class="sig-paren">(</span><em>p=1</em>, <em>weights=None</em>, <em>margin=1.0</em>, <em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#MultiMarginCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.MultiMarginCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that optimizes a multi-class classification hinge loss (margin-based loss)
between input x and output y (which is a target class index).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; </li>
<li><strong>weights</strong> &#8211; </li>
<li><strong>margin</strong> &#8211; </li>
<li><strong>size_average</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiMarginCriterion</span> <span class="o">=</span> <span class="n">MultiMarginCriterion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">weights</span><span class="p">)</span>
<span class="go">creating: createMultiMarginCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiMarginCriterion</span> <span class="o">=</span> <span class="n">MultiMarginCriterion</span><span class="p">()</span>
<span class="go">creating: createMultiMarginCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.ParallelCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">ParallelCriterion</code><span class="sig-paren">(</span><em>repeat_target=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#ParallelCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.ParallelCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>ParallelCriterion is a weighted sum of other criterions each applied to a different input
and target. Set repeatTarget = true to share the target for criterions.</p>
<p>Use add(criterion[, weight]) method to add criterion. Where weight is a scalar(default 1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>repeat_target</strong> &#8211; Whether to share the target for all criterions.</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parallelCriterion</span> <span class="o">=</span> <span class="n">ParallelCriterion</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createParallelCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.SmoothL1Criterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">SmoothL1Criterion</code><span class="sig-paren">(</span><em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#SmoothL1Criterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.SmoothL1Criterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that can be thought of as a smooth version of the AbsCriterion.
It uses a squared term if the absolute element-wise error falls below 1.
It is less sensitive to outliers than the MSECriterion and in some
cases prevents exploding gradients (e.g. see &#8220;Fast R-CNN&#8221; paper by Ross Girshick).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                      <span class="o">|</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">^</span><span class="p">,</span> <span class="k">if</span> <span class="o">|</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">y_i</span><span class="o">|</span> <span class="o">&lt;</span> <span class="mi">1</span>
<span class="n">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span> \<span class="nb">sum</span> <span class="o">|</span>
                      <span class="o">|</span> <span class="o">|</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">y_i</span><span class="o">|</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>   <span class="n">otherwise</span>
</pre></div>
</div>
<p>If x and y are d-dimensional Tensors with a total of n elements,
the sum operation still operates over all the elements, and divides by n.
The division by n can be avoided if one sets the internal variable sizeAverage to false</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size_average</strong> &#8211; whether to average the loss</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smoothL1Criterion</span> <span class="o">=</span> <span class="n">SmoothL1Criterion</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createSmoothL1Criterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.SmoothL1CriterionWithWeights">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">SmoothL1CriterionWithWeights</code><span class="sig-paren">(</span><em>sigma</em>, <em>num=0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#SmoothL1CriterionWithWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.SmoothL1CriterionWithWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>a smooth version of the AbsCriterion
It uses a squared term if the absolute element-wise error falls below 1.
It is less sensitive to outliers than the MSECriterion and in some cases
prevents exploding gradients (e.g. see &#8220;Fast R-CNN&#8221; paper by Ross Girshick).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_in</span>
<span class="n">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w_in</span><span class="p">,</span> <span class="n">w_out</span><span class="p">)</span>
           <span class="o">|</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">d_i</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">w_out</span>          <span class="k">if</span> <span class="o">|</span><span class="n">d_i</span><span class="o">|</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">sigma</span>
<span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span> \<span class="nb">sum</span> <span class="o">|</span>
           <span class="o">|</span> <span class="p">(</span><span class="o">|</span><span class="n">d_i</span><span class="o">|</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_out</span>   <span class="n">otherwise</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">smoothL1CriterionWithWeights</span> <span class="o">=</span> <span class="n">SmoothL1CriterionWithWeights</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSmoothL1CriterionWithWeights</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.SoftMarginCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">SoftMarginCriterion</code><span class="sig-paren">(</span><em>size_average=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#SoftMarginCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.SoftMarginCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Creates a criterion that optimizes a two-class classification logistic loss
between input x (a Tensor of dimension 1) and output y (which is a tensor
containing either 1s or -1s).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">loss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_i</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="o">/</span> <span class="n">x</span><span class="p">:</span><span class="n">nElement</span><span class="p">()</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sizeaverage</strong> &#8211; The normalization by the number of elements in the inputcan be disabled by setting</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softMarginCriterion</span> <span class="o">=</span> <span class="n">SoftMarginCriterion</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">creating: createSoftMarginCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">softMarginCriterion</span> <span class="o">=</span> <span class="n">SoftMarginCriterion</span><span class="p">()</span>
<span class="go">creating: createSoftMarginCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.SoftmaxWithCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">SoftmaxWithCriterion</code><span class="sig-paren">(</span><em>ignore_label=None</em>, <em>normalize_mode='VALID'</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#SoftmaxWithCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.SoftmaxWithCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>Computes the multinomial logistic loss for a one-of-many classification task,
passing real-valued predictions through a softmax to get a probability distribution over classes.
It should be preferred over separate SoftmaxLayer + MultinomialLogisticLossLayer
as its gradient computation is more numerically stable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ignoreLabel</strong> &#8211; (optional) Specify a label value thatshould be ignored when computing the loss.</li>
<li><strong>normalizeMode</strong> &#8211; How to normalize the output loss.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softmaxWithCriterion</span> <span class="o">=</span> <span class="n">SoftmaxWithCriterion</span><span class="p">()</span>
<span class="go">creating: createSoftmaxWithCriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">softmaxWithCriterion</span> <span class="o">=</span> <span class="n">SoftmaxWithCriterion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;FULL&quot;</span><span class="p">)</span>
<span class="go">creating: createSoftmaxWithCriterion</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.criterion.TimeDistributedCriterion">
<em class="property">class </em><code class="descclassname">nn.criterion.</code><code class="descname">TimeDistributedCriterion</code><span class="sig-paren">(</span><em>criterion</em>, <em>size_average=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/criterion.html#TimeDistributedCriterion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.criterion.TimeDistributedCriterion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.criterion.Criterion" title="nn.criterion.Criterion"><code class="xref py py-class docutils literal"><span class="pre">nn.criterion.Criterion</span></code></a></p>
<p>This class is intended to support inputs with 3 or more dimensions.
Apply Any Provided Criterion to every temporal slice of an input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>criterion</strong> &#8211; embedded criterion</li>
<li><strong>size_average</strong> &#8211; whether to divide the sequence length</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">td</span> <span class="o">=</span> <span class="n">TimeDistributedCriterion</span><span class="p">(</span><span class="n">ClassNLLCriterion</span><span class="p">())</span>
<span class="go">creating: createClassNLLCriterion</span>
<span class="go">creating: createTimeDistributedCriterion</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-nn.layer">
<span id="nn-layer-module"></span><h2>nn.layer module<a class="headerlink" href="#module-nn.layer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nn.layer.Abs">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Abs</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Abs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>an element-wise abs operation</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span> <span class="o">=</span> <span class="n">Abs</span><span class="p">()</span>
<span class="go">creating: createAbs</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Add">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Add</code><span class="sig-paren">(</span><em>input_size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>adds a bias term to input data ;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_size</strong> &#8211; size of input data</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createAdd</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.AddConstant">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">AddConstant</code><span class="sig-paren">(</span><em>constant_scalar</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#AddConstant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.AddConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>adding a constant</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>constant_scalar</strong> &#8211; constant value</li>
<li><strong>inplace</strong> &#8211; Can optionally do its operation in-place without using extra state memory</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">addConstant</span> <span class="o">=</span> <span class="n">AddConstant</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createAddConstant</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.BatchNormalization">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">BatchNormalization</code><span class="sig-paren">(</span><em>n_output</em>, <em>eps=1e-05</em>, <em>momentum=0.1</em>, <em>affine=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#BatchNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.BatchNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This layer implements Batch Normalization as described in the paper:
&#8220;Batch Normalization: Accelerating Deep Network Training by Reducing Internal
Covariate Shift&#8221;
by Sergey Ioffe, Christian Szegedy <a class="reference external" href="https://arxiv.org/abs/1502.03167">https://arxiv.org/abs/1502.03167</a></p>
<p>This implementation is useful for inputs NOT coming from convolution layers. For convolution
layers, use nn.SpatialBatchNormalization.</p>
<p>The operation implemented is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       <span class="p">(</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">--------------------</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">+</span> <span class="n">beta</span>
    <span class="n">standard</span><span class="o">-</span><span class="n">deviation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>where gamma and beta are learnable parameters.The learning of gamma and beta is optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_output</strong> &#8211; output feature map number</li>
<li><strong>eps</strong> &#8211; avoid divide zero</li>
<li><strong>momentum</strong> &#8211; momentum for weight update</li>
<li><strong>affine</strong> &#8211; affine operation on output or not</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">batchNormalization</span> <span class="o">=</span> <span class="n">BatchNormalization</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createBatchNormalization</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.BiRecurrent">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">BiRecurrent</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#BiRecurrent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.BiRecurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Create a Bidirectional recurrent layer</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">biRecurrent</span> <span class="o">=</span> <span class="n">BiRecurrent</span><span class="p">()</span>
<span class="go">creating: createBiRecurrent</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Bilinear">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Bilinear</code><span class="sig-paren">(</span><em>input_size1</em>, <em>input_size2</em>, <em>output_size</em>, <em>bias_res=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Bilinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Bilinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>a bilinear transformation with sparse inputs,
The input tensor given in forward(input) is a table containing both inputs x_1 and x_2,
which are tensors of size N x inputDimension1 and N x inputDimension2, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size1</strong> &#8211; input dimension of x_1</li>
<li><strong>input_size2</strong> &#8211; input dimension of x_2</li>
<li><strong>output_size</strong> &#8211; output dimension</li>
<li><strong>bias_res</strong> &#8211; whether use bias</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bilinear</span> <span class="o">=</span> <span class="n">Bilinear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createBilinear</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Bottle">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Bottle</code><span class="sig-paren">(</span><em>module</em>, <em>n_input_dim=2</em>, <em>n_output_dim1=2147483647</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Bottle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Bottle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Bottle allows varying dimensionality input to be forwarded through any module
that accepts input of nInputDim dimensions, and generates output of nOutputDim dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>module</strong> &#8211; transform module</li>
<li><strong>n_input_dim</strong> &#8211; nInputDim dimensions of module</li>
<li><strong>n_output_dim1</strong> &#8211; output of nOutputDim dimensions</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bottle</span> <span class="o">=</span> <span class="n">Bottle</span><span class="p">(</span><span class="n">Linear</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createLinear</span>
<span class="go">creating: createBottle</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CAdd">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CAdd</code><span class="sig-paren">(</span><em>size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CAdd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CAdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This layer has a bias tensor with given size. The bias will be added element wise to the input
tensor. If the element number of the bias tensor match the input tensor, a simply element wise
will be done. Or the bias will be expanded to the same size of the input. The expand means
repeat on unmatched singleton dimension(if some unmatched dimension isn&#8217;t singleton dimension,
it will report an error). If the input is a batch, a singleton dimension will be add to the
first dimension before the expand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; the size of the bias</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cAdd</span> <span class="o">=</span> <span class="n">CAdd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">creating: createCAdd</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CAddTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CAddTable</code><span class="sig-paren">(</span><em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CAddTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CAddTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Merge the input tensors in the input table by element wise adding them together. The input
table is actually an array of tensor with same size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inplace</strong> &#8211; reuse the input memory</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cAddTable</span> <span class="o">=</span> <span class="n">CAddTable</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createCAddTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CDivTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CDivTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CDivTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CDivTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Takes a table with two Tensor and returns the component-wise division between them.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cDivTable</span> <span class="o">=</span> <span class="n">CDivTable</span><span class="p">()</span>
<span class="go">creating: createCDivTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CMaxTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CMaxTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CMaxTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CMaxTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Takes a table of Tensors and outputs the max of all of them.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cMaxTable</span> <span class="o">=</span> <span class="n">CMaxTable</span><span class="p">()</span>
<span class="go">creating: createCMaxTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CMinTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CMinTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CMinTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CMinTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Takes a table of Tensors and outputs the min of all of them.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cMinTable</span> <span class="o">=</span> <span class="n">CMinTable</span><span class="p">()</span>
<span class="go">creating: createCMinTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CMul">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CMul</code><span class="sig-paren">(</span><em>size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CMul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CMul" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a component-wise multiplication to the incoming data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; size of the data</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cMul</span> <span class="o">=</span> <span class="n">CMul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">creating: createCMul</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CMulTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CMulTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CMulTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CMulTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Takes a table of Tensors and outputs the multiplication of all of them.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cMulTable</span> <span class="o">=</span> <span class="n">CMulTable</span><span class="p">()</span>
<span class="go">creating: createCMulTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CSubTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CSubTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CSubTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CSubTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Takes a table with two Tensor and returns the component-wise subtraction between them.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cSubTable</span> <span class="o">=</span> <span class="n">CSubTable</span><span class="p">()</span>
<span class="go">creating: createCSubTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Clamp">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Clamp</code><span class="sig-paren">(</span><em>min</em>, <em>max</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Clamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Clamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Clamps all elements into the range [min_value, max_value].
Output is identical to input in the range,
otherwise elements less than min_value (or greater than max_value)
are saturated to min_value (or max_value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>min</strong> &#8211; </li>
<li><strong>max</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">clamp</span> <span class="o">=</span> <span class="n">Clamp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">creating: createClamp</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Concat">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Concat</code><span class="sig-paren">(</span><em>dimension</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Concat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Concat concatenates the output of one layer of &#8220;parallel&#8221;
modules along the provided {:code dimension}: they take the
same inputs, and their output is concatenated.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                <span class="o">+-----------+</span>
           <span class="o">+----&gt;</span>  <span class="n">module1</span>  <span class="o">-----+</span>
           <span class="o">|</span>    <span class="o">|</span>           <span class="o">|</span>    <span class="o">|</span>
<span class="nb">input</span> <span class="o">-----+----&gt;</span>  <span class="n">module2</span>  <span class="o">-----+----&gt;</span> <span class="n">output</span>
           <span class="o">|</span>    <span class="o">|</span>           <span class="o">|</span>    <span class="o">|</span>
           <span class="o">+----&gt;</span>  <span class="n">module3</span>  <span class="o">-----+</span>
                <span class="o">+-----------+</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dimension</strong> &#8211; dimension</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">concat</span> <span class="o">=</span> <span class="n">Concat</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating: createConcat</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.ConcatTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">ConcatTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#ConcatTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.ConcatTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>ConcateTable is a container module like Concate. Applies an input
to each member module, input can be a tensor or a table.</p>
<p>ConcateTable usually works with CAddTable and CMulTable to
implement element wise add/multiply on outputs of two modules.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">concatTable</span> <span class="o">=</span> <span class="n">ConcatTable</span><span class="p">()</span>
<span class="go">creating: createConcatTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Contiguous">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Contiguous</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Contiguous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>used to make input, grad_output both contiguous</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">contiguous</span> <span class="o">=</span> <span class="n">Contiguous</span><span class="p">()</span>
<span class="go">creating: createContiguous</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Cosine">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Cosine</code><span class="sig-paren">(</span><em>input_size</em>, <em>output_size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Cosine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Cosine calculates the cosine similarity of the input to k mean centers. The input given in
forward(input) must be either a vector (1D tensor) or matrix (2D tensor). If the input is a
vector, it must have the size of inputSize. If it is a matrix, then each row is assumed to be
an input sample of given batch (the number of rows means the batch size and the number of
columns should be equal to the inputSize).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size</strong> &#8211; the size of each input sample</li>
<li><strong>output_size</strong> &#8211; the size of the module output of each sample</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cosine</span> <span class="o">=</span> <span class="n">Cosine</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">creating: createCosine</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CosineDistance">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CosineDistance</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CosineDistance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CosineDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Outputs the cosine distance between inputs</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cosineDistance</span> <span class="o">=</span> <span class="n">CosineDistance</span><span class="p">()</span>
<span class="go">creating: createCosineDistance</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.CriterionTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">CriterionTable</code><span class="sig-paren">(</span><em>criterion</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#CriterionTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.CriterionTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Creates a module that wraps a Criterion so that it can accept a table of inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>criterion</strong> &#8211; Criterion module</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nn.criterion</span> <span class="k">import</span> <span class="n">MSECriterion</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">criterionTable</span> <span class="o">=</span> <span class="n">CriterionTable</span><span class="p">(</span><span class="n">MSECriterion</span><span class="p">())</span>
<span class="go">creating: createMSECriterion</span>
<span class="go">creating: createCriterionTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.DotProduct">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">DotProduct</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#DotProduct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.DotProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This is a simple table layer which takes a table of two tensors as input
and calculate the dot product between them as outputs</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dotProduct</span> <span class="o">=</span> <span class="n">DotProduct</span><span class="p">()</span>
<span class="go">creating: createDotProduct</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Dropout">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Dropout</code><span class="sig-paren">(</span><em>init_p=0.5</em>, <em>inplace=False</em>, <em>scale=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Dropout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Dropout masks(set to zero) parts of input using a bernoulli distribution.
Each input element has a probability initP of being dropped. If scale is
set, the outputs are scaled by a factor of 1/(1-initP) during training.
During evaluating, output is the same as input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initP</strong> &#8211; probability to be dropped</li>
<li><strong>inplace</strong> &#8211; inplace model</li>
<li><strong>scale</strong> &#8211; if scale by a factor of 1/(1-initP)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dropout</span> <span class="o">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>
<span class="go">creating: createDropout</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.ELU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">ELU</code><span class="sig-paren">(</span><em>alpha=1.0</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#ELU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.ELU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>D-A Clevert, Thomas Unterthiner, Sepp Hochreiter
Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
[<a class="reference external" href="http://arxiv.org/pdf/1511.07289.pdf">http://arxiv.org/pdf/1511.07289.pdf</a>]</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eLU</span> <span class="o">=</span> <span class="n">ELU</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createELU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Echo">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Echo</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Echo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Echo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This module is for debug purpose, which can print activation and gradient in your model
topology</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">echo</span> <span class="o">=</span> <span class="n">Echo</span><span class="p">()</span>
<span class="go">creating: createEcho</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Euclidean">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Euclidean</code><span class="sig-paren">(</span><em>input_size</em>, <em>output_size</em>, <em>fast_backward=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Euclidean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Outputs the Euclidean distance of the input to outputSize centers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputSize</strong> &#8211; inputSize</li>
<li><strong>outputSize</strong> &#8211; outputSize</li>
<li><strong>T</strong> &#8211; Numeric type. Only support float/double now</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">euclidean</span> <span class="o">=</span> <span class="n">Euclidean</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createEuclidean</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Exp">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Exp</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies element-wise exp to input tensor.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span> <span class="o">=</span> <span class="n">Exp</span><span class="p">()</span>
<span class="go">creating: createExp</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.FlattenTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">FlattenTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#FlattenTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.FlattenTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This is a table layer which takes an arbitrarily deep table of Tensors
(potentially nested) as input and a table of Tensors without any nested
table will be produced</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flattenTable</span> <span class="o">=</span> <span class="n">FlattenTable</span><span class="p">()</span>
<span class="go">creating: createFlattenTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.GRU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">GRU</code><span class="sig-paren">(</span><em>input_size</em>, <em>hidden_size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#GRU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.GRU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Gated Recurrent Units architecture.
The first input in sequence uses zero value for cell and hidden state</p>
<div class="line-block">
<div class="line">Ref.</div>
<div class="line"><a class="reference external" href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/">http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/</a></div>
<div class="line"><a class="reference external" href="https://github.com/Element-Research/rnn/blob/master/GRU.lua">https://github.com/Element-Research/rnn/blob/master/GRU.lua</a></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size</strong> &#8211; the size of each input vector</li>
<li><strong>hidden_size</strong> &#8211; Hidden unit size in GRU</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gru</span> <span class="o">=</span> <span class="n">GRU</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">creating: createGRU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.GradientReversal">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">GradientReversal</code><span class="sig-paren">(</span><em>the_lambda=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#GradientReversal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.GradientReversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a simple module preserves the input, but takes the
gradient from the subsequent layer, multiplies it by -lambda
and passes it to the preceding layer. This can be used to maximise
an objective function whilst using gradient descent, as described in
[&#8220;Domain-Adversarial Training of Neural Networks&#8221;
(<a class="reference external" href="http://arxiv.org/abs/1505.07818">http://arxiv.org/abs/1505.07818</a>)]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lambda</strong> &#8211; hyper-parameter lambda can be set dynamically during training</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gradientReversal</span> <span class="o">=</span> <span class="n">GradientReversal</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createGradientReversal</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.HardShrink">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">HardShrink</code><span class="sig-paren">(</span><em>the_lambda=0.5</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#HardShrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.HardShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This is a transfer layer which applies the hard shrinkage function
element-wise to the input Tensor. The parameter lambda is set to 0.5
by default</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">x</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span>  <span class="k">lambda</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span>  <span class="n">x</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="k">lambda</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">otherwise</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>the_lambda</strong> &#8211; a threshold value whose default value is 0.5</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hardShrink</span> <span class="o">=</span> <span class="n">HardShrink</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createHardShrink</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.HardTanh">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">HardTanh</code><span class="sig-paren">(</span><em>min_value=-1</em>, <em>max_value=1</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#HardTanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.HardTanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies HardTanh to each element of input, HardTanh is defined:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       <span class="o">|</span>  <span class="n">maxValue</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxValue</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span>  <span class="n">minValue</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">minValue</span>
       <span class="o">|</span>  <span class="n">x</span><span class="p">,</span> <span class="n">otherwise</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>min_value</strong> &#8211; minValue in f(x), default is -1.</li>
<li><strong>max_value</strong> &#8211; maxValue in f(x), default is 1.</li>
<li><strong>inplace</strong> &#8211; whether enable inplace model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hardTanh</span> <span class="o">=</span> <span class="n">HardTanh</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createHardTanh</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Identity">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Identity</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Identity just return the input to output.
It&#8217;s useful in same parallel container to get an origin input.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">identity</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">()</span>
<span class="go">creating: createIdentity</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Index">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Index</code><span class="sig-paren">(</span><em>dimension</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the Tensor index operation along the given dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dimension</strong> &#8211; the dimension to be indexed</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createIndex</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.InferReshape">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">InferReshape</code><span class="sig-paren">(</span><em>size</em>, <em>batch_mode=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#InferReshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.InferReshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Reshape with the support of infered size,
Positive numbers are used directly, setting the corresponding dimension of the output tensor.
In addition, two special values are accepted:
0 means &#8220;copy the respective dimension of the input&#8221;.
i.e., if the input has 2 as its 1st dimension,
the output will have 2 as its 1st dimension as well
-1 stands for &#8220;infer this from the other dimensions&#8221;
this dimension is calculated to keep the overall element count the same as in the input.
At most one -1 can be used in a reshape operation.
For example, (4, 5, 6, 7) -&gt; InferReshape (4, 0, 3, -1) -&gt; (4, 5, 3, 14)
with 1st and 3rd dim same as given size, with 2nd dim same as input, and the infered dim is 14</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> &#8211; the target tensor size</li>
<li><strong>batch_mode</strong> &#8211; whether in batch mode</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inferReshape</span> <span class="o">=</span> <span class="n">InferReshape</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">creating: createInferReshape</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.JoinTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">JoinTable</code><span class="sig-paren">(</span><em>dimension</em>, <em>n_input_dims</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#JoinTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.JoinTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a table module which takes a table of Tensors as input and
outputs a Tensor by joining them together along the dimension <cite>dimension</cite>.</p>
<p>The input to this layer is expected to be a tensor, or a batch of tensors;
when using mini-batch, a batch of sample tensors will be passed to the layer and
the user need to specify the number of dimensions of each sample tensor in the
batch using <cite>nInputDims</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; to be join in this dimension</li>
<li><strong>nInputDims</strong> &#8211; specify the number of dimensions that this module will receiveIf it is more than the dimension of input tensors, the first dimensionwould be considered as batch size</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">joinTable</span> <span class="o">=</span> <span class="n">JoinTable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createJoinTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.L1Cost">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">L1Cost</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#L1Cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.L1Cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>compute L1 norm for input, and sign of input</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l1Cost</span> <span class="o">=</span> <span class="n">L1Cost</span><span class="p">()</span>
<span class="go">creating: createL1Cost</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.L1Penalty">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">L1Penalty</code><span class="sig-paren">(</span><em>l1weight</em>, <em>size_average=False</em>, <em>provide_output=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#L1Penalty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.L1Penalty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>adds an L1 penalty to an input (for sparsity).
L1Penalty is an inline module that in its forward propagation copies the input Tensor
directly to the output, and computes an L1 loss of the latent state (input) and stores
it in the module&#8217;s loss field. During backward propagation: gradInput = gradOutput + gradLoss.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>l1weight</strong> &#8211; </li>
<li><strong>sizeAverage</strong> &#8211; </li>
<li><strong>provideOutput</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l1Penalty</span> <span class="o">=</span> <span class="n">L1Penalty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createL1Penalty</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LSTM">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LSTM</code><span class="sig-paren">(</span><em>input_size</em>, <em>hidden_size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LSTM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LSTM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<div class="line-block">
<div class="line">Long Short Term Memory architecture.</div>
<div class="line">Ref.</div>
<div class="line">A.: <a class="reference external" href="http://arxiv.org/pdf/1303.5778v1">http://arxiv.org/pdf/1303.5778v1</a> (blueprint for this module)</div>
<div class="line">B. <a class="reference external" href="http://web.eecs.utk.edu/~itamar/courses/ECE-692/Bobby_paper1.pdf">http://web.eecs.utk.edu/~itamar/courses/ECE-692/Bobby_paper1.pdf</a></div>
<div class="line">C. <a class="reference external" href="http://arxiv.org/pdf/1503.04069v1.pdf">http://arxiv.org/pdf/1503.04069v1.pdf</a></div>
<div class="line">D. <a class="reference external" href="https://github.com/wojzaremba/lstm">https://github.com/wojzaremba/lstm</a></div>
<div class="line">E. <a class="reference external" href="https://github.com/Element-Research/rnn/blob/master/FastLSTM.lua">https://github.com/Element-Research/rnn/blob/master/FastLSTM.lua</a></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputSize</strong> &#8211; the size of each input vector</li>
<li><strong>hiddenSize</strong> &#8211; Hidden unit size in the LSTM</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lstm</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">creating: createLSTM</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LSTMPeephole">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LSTMPeephole</code><span class="sig-paren">(</span><em>input_size</em>, <em>hidden_size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LSTMPeephole"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LSTMPeephole" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<div class="line-block">
<div class="line">Long Short Term Memory architecture with peephole.</div>
<div class="line">Ref. A.: <a class="reference external" href="http://arxiv.org/pdf/1303.5778v1">http://arxiv.org/pdf/1303.5778v1</a> (blueprint for this module)</div>
<div class="line">B. <a class="reference external" href="http://web.eecs.utk.edu/~itamar/courses/ECE-692/Bobby_paper1.pdf">http://web.eecs.utk.edu/~itamar/courses/ECE-692/Bobby_paper1.pdf</a></div>
<div class="line">C. <a class="reference external" href="http://arxiv.org/pdf/1503.04069v1.pdf">http://arxiv.org/pdf/1503.04069v1.pdf</a></div>
<div class="line">D. <a class="reference external" href="https://github.com/wojzaremba/lstm">https://github.com/wojzaremba/lstm</a></div>
<div class="line">E. <a class="reference external" href="https://github.com/Element-Research/rnn/blob/master/LSTM.lua">https://github.com/Element-Research/rnn/blob/master/LSTM.lua</a></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size</strong> &#8211; the size of each input vector</li>
<li><strong>hidden_size</strong> &#8211; Hidden unit size in the LSTM</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lstm</span> <span class="o">=</span> <span class="n">LSTMPeephole</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">creating: createLSTMPeephole</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LeakyReLU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LeakyReLU</code><span class="sig-paren">(</span><em>negval=0.01</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LeakyReLU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LeakyReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a transfer module that applies LeakyReLU, which parameter negval sets the slope of the
negative part: LeakyReLU is defined as: f(x) = max(0, x) + negval * min(0, x)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>negval</strong> &#8211; sets the slope of the negative partl</li>
<li><strong>inplace</strong> &#8211; if it is true, doing the operation in-place without using extra state memory</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">leakyReLU</span> <span class="o">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createLeakyReLU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Linear">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>input_size</em>, <em>output_size</em>, <em>init_method='default'</em>, <em>with_bias=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>The [[Linear]] module applies a linear transformation to the input data,
i.e. <cite>y = Wx + b</cite>. The input given in <cite>forward(input)</cite> must be either
a vector (1D tensor) or matrix (2D tensor). If the input is a vector, it must
have the size of <cite>inputSize</cite>. If it is a matrix, then each row is assumed to be
an input sample of given batch (the number of rows means the batch size and
the number of columns should be equal to the <cite>inputSize</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size</strong> &#8211; the size the each input sample</li>
<li><strong>output_size</strong> &#8211; the size of the module output of each sample</li>
<li><strong>init_method</strong> &#8211; two initialized methods are supported here, which are [[Default]]and [[Xavier]], where [[Xavier]] set bias to zero here. For moredetailed information about <cite>initMethod</cite>, please refer to[[InitializationMethod]]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linear</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;Xavier&quot;</span><span class="p">)</span>
<span class="go">creating: createLinear</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Log">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Log</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Log" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the log function element-wise to the input Tensor,
thus outputting a Tensor of the same dimension.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">log</span> <span class="o">=</span> <span class="n">Log</span><span class="p">()</span>
<span class="go">creating: createLog</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LogSigmoid">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LogSigmoid</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LogSigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LogSigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This class is a transform layer corresponding to the sigmoid function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e</span> <span class="o">^^</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">logSigmoid</span> <span class="o">=</span> <span class="n">LogSigmoid</span><span class="p">()</span>
<span class="go">creating: createLogSigmoid</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LogSoftMax">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LogSoftMax</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LogSoftMax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LogSoftMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the LogSoftMax function to an n-dimensional input Tensor.
LogSoftmax is defined as: f_i(x) = log(1 / a exp(x_i))
where a = sum_j[exp(x_j)].</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">logSoftMax</span> <span class="o">=</span> <span class="n">LogSoftMax</span><span class="p">()</span>
<span class="go">creating: createLogSoftMax</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.LookupTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">LookupTable</code><span class="sig-paren">(</span><em>n_index</em>, <em>n_output</em>, <em>padding_value=0</em>, <em>max_norm=1.7976931348623157e+308</em>, <em>norm_type=2.0</em>, <em>should_scale_grad_by_freq=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#LookupTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.LookupTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>a convolution of width 1, commonly used for word embeddings</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lookupTable</span> <span class="o">=</span> <span class="n">LookupTable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createLookupTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MM">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MM</code><span class="sig-paren">(</span><em>trans_a=False</em>, <em>trans_b=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Module to perform matrix multiplication on two mini-batch inputs, producing a mini-batch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>trans_a</strong> &#8211; specifying whether or not transpose the first input matrix</li>
<li><strong>trans_b</strong> &#8211; specifying whether or not transpose the second input matrix</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mM</span> <span class="o">=</span> <span class="n">MM</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createMM</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MV">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MV</code><span class="sig-paren">(</span><em>trans=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MV" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a module to perform matrix vector multiplication on two mini-batch inputs,
producing a mini-batch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trans</strong> &#8211; whether make matrix transpose before multiplication</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mV</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createMV</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MapTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MapTable</code><span class="sig-paren">(</span><em>module</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MapTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MapTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This class is a container for a single module which will be applied
to all input elements. The member module is cloned as necessary to
process all input elements.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mapTable</span> <span class="o">=</span> <span class="n">MapTable</span><span class="p">(</span><span class="n">Linear</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="go">creating: createLinear</span>
<span class="go">creating: createMapTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MaskedSelect">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MaskedSelect</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MaskedSelect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MaskedSelect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Performs a torch.MaskedSelect on a Tensor. The mask is supplied as a tabular argument with
the input on the forward and backward passes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maskedSelect</span> <span class="o">=</span> <span class="n">MaskedSelect</span><span class="p">()</span>
<span class="go">creating: createMaskedSelect</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Max">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Max</code><span class="sig-paren">(</span><em>dim</em>, <em>num_input_dims=-2147483648</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Max" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a max operation over dimension <cite>dim</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; max along this dimension</li>
<li><strong>num_input_dims</strong> &#8211; Optional. If in a batch model, set to the inputDims.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createMax</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Mean">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Mean</code><span class="sig-paren">(</span><em>dimension=1</em>, <em>n_input_dims=-1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a simple layer which applies a mean operation over the given dimension. When nInputDims
is provided, the input will be considered as batches. Then the mean operation will be applied
in (dimension + 1). The input to this layer is expected to be a tensor, or a batch of
tensors; when using mini-batch, a batch of sample tensors will be passed to the layer and the
user need to specify the number of dimensions of each sample tensor in the batch using
nInputDims.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; the dimension to be applied mean operation</li>
<li><strong>n_input_dims</strong> &#8211; specify the number of dimensions that this module will receiveIf it is more than the dimension of input tensors, the first dimension would be consideredas batch size</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">Mean</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createMean</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Min">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Min</code><span class="sig-paren">(</span><em>dim</em>, <em>num_input_dims=-2147483648</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Min" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a min operation over dimension <cite>dim</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; min along this dimension</li>
<li><strong>num_input_dims</strong> &#8211; Optional. If in a batch model, set to the input_dim.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span> <span class="o">=</span> <span class="n">Min</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createMin</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MixtureTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MixtureTable</code><span class="sig-paren">(</span><em>dim=2147483647</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MixtureTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MixtureTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Creates a module that takes a table {gater, experts} as input and outputs the mixture of experts
(a Tensor or table of Tensors) using a gater Tensor. When dim is provided, it specifies the
dimension of the experts Tensor that will be interpolated (or mixed). Otherwise, the experts
should take the form of a table of Tensors. This Module works for experts of dimension 1D or
more, and for a 1D or 2D gater, i.e. for single examples or mini-batches.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mixtureTable</span> <span class="o">=</span> <span class="n">MixtureTable</span><span class="p">()</span>
<span class="go">creating: createMixtureTable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mixtureTable</span> <span class="o">=</span> <span class="n">MixtureTable</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">creating: createMixtureTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Model">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>jvalue</em>, <em>bigdl_type</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="util.html#util.common.JavaValue" title="util.common.JavaValue"><code class="xref py py-class docutils literal"><span class="pre">util.common.JavaValue</span></code></a></p>
<p>Model is the basic component of a neural network
and it&#8217;s also the base class of layers.
Model can connect to others to construct a complex neural network.</p>
<dl class="method">
<dt id="nn.layer.Model.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.get_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="nn.layer.Model.load">
<em class="property">static </em><code class="descname">load</code><span class="sig-paren">(</span><em>path</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a pre-trained Bigdl model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; The path containing the pre-trained model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pre-trained model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="nn.layer.Model.load_caffe">
<em class="property">static </em><code class="descname">load_caffe</code><span class="sig-paren">(</span><em>model</em>, <em>defPath</em>, <em>modelPath</em>, <em>match_all=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.load_caffe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.load_caffe" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a pre-trained Caffe model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>model</strong> &#8211; A bigdl model definition         which equivalent to the pre-trained caffe model.</li>
<li><strong>defPath</strong> &#8211; The path containing the caffe model definition.</li>
<li><strong>modelPath</strong> &#8211; The path containing the pre-trained caffe model.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pre-trained model.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="nn.layer.Model.load_torch">
<em class="property">static </em><code class="descname">load_torch</code><span class="sig-paren">(</span><em>path</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.load_torch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.load_torch" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a pre-trained Torch model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; The path containing the pre-trained model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pre-trained model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of this layer</p>
</dd></dl>

<dl class="classmethod">
<dt id="nn.layer.Model.of">
<em class="property">classmethod </em><code class="descname">of</code><span class="sig-paren">(</span><em>jmodel</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.of" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Python Model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>jmodel</strong> &#8211; Java model create by Py4j</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Python Model</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.parameters">
<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the model parameters which containing: weight, bias, gradBias, gradWeight</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict(layername -&gt; dict(parametername -&gt; ndarray))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>data_rdd</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Model inference base on the given data.
You need to invoke collect() to trigger those action         as the returning result is an RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data_rdd</strong> &#8211; the data to be predict.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An RDD represent the predict result.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the model weights.</p>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.set_name">
<code class="descname">set_name</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.set_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Give this model a name. There would be a generated name
consist of class name and UUID if user doesn&#8217;t set it.</p>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.set_seed">
<code class="descname">set_seed</code><span class="sig-paren">(</span><em>seed=123</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.set_seed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.set_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>You can control the random seed which used to init weights for this model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seed</strong> &#8211; random seed</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Model itself.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nn.layer.Model.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>val_rdd</em>, <em>batch_size</em>, <em>val_methods</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Model.test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Model.test" title="Permalink to this definition">¶</a></dt>
<dd><p>A method to benchmark the model quality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val_rdd</strong> &#8211; the input data</li>
<li><strong>batch_size</strong> &#8211; batch size</li>
<li><strong>val_methods</strong> &#8211; a list of validation methods. i.e: Top1Accuracy,Top5Accuracy and Loss.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nn.layer.Mul">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Mul</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Mul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Multiply a single scalar factor to the incoming data</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">()</span>
<span class="go">creating: createMul</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.MulConstant">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">MulConstant</code><span class="sig-paren">(</span><em>scalar</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#MulConstant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.MulConstant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Multiplies input Tensor by a (non-learnable) scalar constant.
This module is sometimes useful for debugging purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scalar</strong> &#8211; scalar constant</li>
<li><strong>inplace</strong> &#8211; Can optionally do its operation in-place without using extra state memory</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mulConstant</span> <span class="o">=</span> <span class="n">MulConstant</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
<span class="go">creating: createMulConstant</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Narrow">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Narrow</code><span class="sig-paren">(</span><em>dimension</em>, <em>offset</em>, <em>length=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Narrow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Narrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Narrow is application of narrow operation in a module.
The module further supports a negative length in order to handle inputs with an unknown size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">narrow</span> <span class="o">=</span> <span class="n">Narrow</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createNarrow</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.NarrowTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">NarrowTable</code><span class="sig-paren">(</span><em>offset</em>, <em>length=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#NarrowTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.NarrowTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Creates a module that takes a table as input and outputs the subtable starting at index
offset having length elements (defaults to 1 element). The elements can be either
a table or a Tensor. If <cite>length</cite> is negative, it means selecting the elements from the
offset to element which located at the abs(<cite>length</cite>) to the last element of the input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; the start index of table</li>
<li><strong>length</strong> &#8211; the length want to select</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">narrowTable</span> <span class="o">=</span> <span class="n">NarrowTable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createNarrowTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Normalize">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Normalize</code><span class="sig-paren">(</span><em>p</em>, <em>eps=1e-10</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Normalizes the input Tensor to have unit L_p norm. The smoothing parameter eps prevents
division by zero when the input contains all zero elements (default = 1e-10).
p can be the max value of double</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">normalize</span> <span class="o">=</span> <span class="n">Normalize</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createNormalize</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.PReLU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">PReLU</code><span class="sig-paren">(</span><em>n_output_plane=0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#PReLU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.PReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies parametric ReLU, which parameter varies the slope of the negative part.</p>
<p>PReLU: f(x) = max(0, x) + a * min(0, x)</p>
<p>nOutputPlane&#8217;s default value is 0, that means using PReLU in shared version and has
only one parameters.</p>
<p>Notice: Please don&#8217;t use weight decay on this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n_output_plane</strong> &#8211; input map number. Default is 0.</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pReLU</span> <span class="o">=</span> <span class="n">PReLU</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createPReLU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Padding">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Padding</code><span class="sig-paren">(</span><em>dim</em>, <em>pad</em>, <em>n_input_dim</em>, <em>value=0.0</em>, <em>n_index=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Padding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Padding" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This module adds pad units of padding to dimension dim of the input. If pad is negative,
padding is added to the left, otherwise, it is added to the right of the dimension.</p>
<p>The input to this layer is expected to be a tensor, or a batch of tensors;
when using mini-batch, a batch of sample tensors will be passed to the layer and
the user need to specify the number of dimensions of each sample tensor in the
batch using n_input_dim.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; the dimension to be applied padding operation</li>
<li><strong>pad</strong> &#8211; num of the pad units</li>
<li><strong>n_input_dim</strong> &#8211; specify the number of dimensions that this module will receiveIf it is more than the dimension of input tensors, the first dimensionwould be considered as batch size</li>
<li><strong>value</strong> &#8211; padding value</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">padding</span> <span class="o">=</span> <span class="n">Padding</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createPadding</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.PairwiseDistance">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">PairwiseDistance</code><span class="sig-paren">(</span><em>norm=2</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#PairwiseDistance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.PairwiseDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a module that takes a table of two vectors as input and outputs
the distance between them using the p-norm.
The input given in <cite>forward(input)</cite> is a [[Table]] that contains two tensors which
must be either a vector (1D tensor) or matrix (2D tensor). If the input is a vector,
it must have the size of <cite>inputSize</cite>. If it is a matrix, then each row is assumed to be
an input sample of the given batch (the number of rows means the batch size and
the number of columns should be equal to the <cite>inputSize</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>norm</strong> &#8211; the norm of distance</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pairwiseDistance</span> <span class="o">=</span> <span class="n">PairwiseDistance</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating: createPairwiseDistance</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.ParallelTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">ParallelTable</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#ParallelTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.ParallelTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a container module that applies the i-th member module to the i-th
input, and outputs an output in the form of Table</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parallelTable</span> <span class="o">=</span> <span class="n">ParallelTable</span><span class="p">()</span>
<span class="go">creating: createParallelTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Power">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Power</code><span class="sig-paren">(</span><em>power</em>, <em>scale=1.0</em>, <em>shift=0.0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Power" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply an element-wise power operation with scale and shift.
f(x) = (shift + scale * x)^power^</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>power</strong> &#8211; the exponent.</li>
<li><strong>scale</strong> &#8211; Default is 1.</li>
<li><strong>shift</strong> &#8211; Default is 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">power</span> <span class="o">=</span> <span class="n">Power</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createPower</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.RReLU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">RReLU</code><span class="sig-paren">(</span><em>lower=0.125</em>, <em>upper=0.3333333333333333</em>, <em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#RReLU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.RReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the randomized leaky rectified linear unit (RReLU) element-wise to the input Tensor,
thus outputting a Tensor of the same dimension. Informally the RReLU is also known as
&#8216;insanity&#8217; layer. RReLU is defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="n">where</span> <span class="n">a</span> <span class="o">~</span> <span class="n">U</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>In training mode negative inputs are multiplied by a factor a drawn from a uniform random
distribution U(l, u).</p>
<p>In evaluation mode a RReLU behaves like a LeakyReLU with a constant mean factor
a = (l + u) / 2.</p>
<p>By default, l = 1/8 and u = 1/3. If l == u a RReLU effectively becomes a LeakyReLU.</p>
<p>Regardless of operating in in-place mode a RReLU will internally allocate an input-sized
noise tensor to store random factors for negative inputs.</p>
<p>The backward() operation assumes that forward() has been called before.</p>
<p>For reference see [Empirical Evaluation of Rectified Activations in Convolutional Network](
<a class="reference external" href="http://arxiv.org/abs/1505.00853">http://arxiv.org/abs/1505.00853</a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lower</strong> &#8211; lower boundary of uniform random distribution</li>
<li><strong>upper</strong> &#8211; upper boundary of uniform random distribution</li>
<li><strong>inplace</strong> &#8211; optionally do its operation in-place without using extra state memory</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rReLU</span> <span class="o">=</span> <span class="n">RReLU</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createRReLU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.ReLU">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">ReLU</code><span class="sig-paren">(</span><em>ip=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#ReLU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.ReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the rectified linear unit (ReLU) function element-wise to the input Tensor,
thus outputting a Tensor of the same dimension.</p>
<p>ReLU is defined as: f(x) = max(0, x)
Can optionally do its operation in-place without using extra state memory</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">relu</span> <span class="o">=</span> <span class="n">ReLU</span><span class="p">()</span>
<span class="go">creating: createReLU</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.ReLU6">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">ReLU6</code><span class="sig-paren">(</span><em>inplace=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#ReLU6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.ReLU6" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Same as ReLU except that the rectifying function f(x) saturates at x = 6</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inplace</strong> &#8211; either True = in-place or False = keeping separate state</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reLU6</span> <span class="o">=</span> <span class="n">ReLU6</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createReLU6</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Recurrent">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Recurrent</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Recurrent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Recurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Recurrent module is a container of rnn cells
Different types of rnn cells can be added using add() function</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">recurrent</span> <span class="o">=</span> <span class="n">Recurrent</span><span class="p">()</span>
<span class="go">creating: createRecurrent</span>
</pre></div>
</div>
<dl class="method">
<dt id="nn.layer.Recurrent.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Recurrent.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Recurrent.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nn.layer.Replicate">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Replicate</code><span class="sig-paren">(</span><em>n_features</em>, <em>dim=1</em>, <em>n_dim=2147483647</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Replicate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Replicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Replicate repeats input <cite>nFeatures</cite> times along its <cite>dim</cite> dimension.
Notice: No memory copy, it set the stride along the <cite>dim</cite>-th dimension to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_features</strong> &#8211; replicate times.</li>
<li><strong>dim</strong> &#8211; dimension to be replicated.</li>
<li><strong>n_dim</strong> &#8211; specify the number of non-batch dimensions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">replicate</span> <span class="o">=</span> <span class="n">Replicate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating: createReplicate</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Reshape">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Reshape</code><span class="sig-paren">(</span><em>size</em>, <em>batch_mode=None</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Reshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>The forward(input) reshape the input tensor into a size(0) * size(1) * ... tensor, taking the
elements row-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; the reshape size</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span> <span class="o">=</span> <span class="n">Reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">])</span>
<span class="go">creating: createReshape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span> <span class="o">=</span> <span class="n">Reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">creating: createReshape</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Reverse">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Reverse</code><span class="sig-paren">(</span><em>dimension=1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Reverse the input w.r.t given dimension.
The input can be a Tensor or Table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dim</strong> &#8211; </td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reverse</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">()</span>
<span class="go">creating: createReverse</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.RnnCell">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">RnnCell</code><span class="sig-paren">(</span><em>input_size</em>, <em>hidden_size</em>, <em>activation</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#RnnCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.RnnCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a simple RNN. User can pass an activation function to the RNN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_size</strong> &#8211; the size of each input vector</li>
<li><strong>hidden_size</strong> &#8211; Hidden unit size in simple RNN</li>
<li><strong>activation</strong> &#8211; activation function</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span> <span class="o">=</span> <span class="n">RnnCell</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Tanh</span><span class="p">())</span>
<span class="go">creating: createTanh</span>
<span class="go">creating: createRnnCell</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.RoiPooling">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">RoiPooling</code><span class="sig-paren">(</span><em>pooled_w</em>, <em>pooled_h</em>, <em>spatial_scale</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#RoiPooling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.RoiPooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Region of interest pooling
The RoIPooling uses max pooling to convert the features inside any valid region of interest
into a small feature map with a fixed spatial extent of pooledH * pooledW (e.g., 7 * 7)
an RoI is a rectangular window into a conv feature map.
Each RoI is defined by a four-tuple (x1, y1, x2, y2) that specifies its
top-left corner (x1, y1) and its bottom-right corner (x2, y2).
RoI max pooling works by dividing the h * w RoI window into an pooledH * pooledW grid of
sub-windows of approximate size h/H * w/W and then max-pooling the values in each sub-window
into the corresponding output grid cell.
Pooling is applied independently to each feature map channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pooled_w</strong> &#8211; spatial extent in width</li>
<li><strong>pooled_h</strong> &#8211; spatial extent in height</li>
<li><strong>spatial_scale</strong> &#8211; spatial scale</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">roiPooling</span> <span class="o">=</span> <span class="n">RoiPooling</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createRoiPooling</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Scale">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Scale</code><span class="sig-paren">(</span><em>size</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Scale is the combination of CMul and CAdd
Computes the elementwise product of input and weight, with the shape of the weight &#8220;expand&#8221; to
match the shape of the input.
Similarly, perform a expand cdd bias and perform an elementwise add</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; size of weight and bias</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="n">Scale</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">creating: createScale</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Select">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Select</code><span class="sig-paren">(</span><em>dim</em>, <em>index</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Select" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>A Simple layer selecting an index of the input tensor in the given dimension</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; the dimension to select</li>
<li><strong>index</strong> &#8211; the index of the dimension to be selected</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">select</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSelect</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SelectTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SelectTable</code><span class="sig-paren">(</span><em>dimension</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SelectTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SelectTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Creates a module that takes a table as input and outputs the element at index <cite>index</cite>
(positive or negative). This can be either a table or a Tensor.
The gradients of the non-index elements are zeroed Tensors of the same size.
This is true regardless of the depth of the encapsulated Tensor as the function used
internally to do so is recursive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dimension</strong> &#8211; the dimension to be selected</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">selectTable</span> <span class="o">=</span> <span class="n">SelectTable</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSelectTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Sequential">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Sequential</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Sequential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Sequential provides a means to plug layers together
in a feed-forward fully connected manner.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">echo</span> <span class="o">=</span> <span class="n">Echo</span><span class="p">()</span>
<span class="go">creating: createEcho</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="go">creating: createSequential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">echo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">echo</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="nn.layer.Sequential.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>model</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Sequential.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Sequential.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nn.layer.Sigmoid">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Sigmoid</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the Sigmoid function element-wise to the input Tensor,
thus outputting a Tensor of the same dimension.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">Sigmoid</span><span class="p">()</span>
<span class="go">creating: createSigmoid</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SoftMax">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SoftMax</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SoftMax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SoftMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the SoftMax function to an n-dimensional input Tensor, rescaling them so that the
elements of the n-dimensional output Tensor lie in the range (0, 1) and sum to 1.
Softmax is defined as: f_i(x) = exp(x_i - shift) / sum_j exp(x_j - shift)
where shift = max_i(x_i).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softMax</span> <span class="o">=</span> <span class="n">SoftMax</span><span class="p">()</span>
<span class="go">creating: createSoftMax</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SoftMin">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SoftMin</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SoftMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SoftMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the SoftMin function to an n-dimensional input Tensor, rescaling them so that the
elements of the n-dimensional output Tensor lie in the range (0,1) and sum to 1.
Softmin is defined as: f_i(x) = exp(-x_i - shift) / sum_j exp(-x_j - shift)
where shift = max_i(-x_i).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softMin</span> <span class="o">=</span> <span class="n">SoftMin</span><span class="p">()</span>
<span class="go">creating: createSoftMin</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SoftPlus">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SoftPlus</code><span class="sig-paren">(</span><em>beta=1.0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SoftPlus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SoftPlus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply the SoftPlus function to an n-dimensional input tensor.
SoftPlus function: f_i(x) = 1/beta * log(1 + exp(beta * x_i))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>beta</strong> &#8211; Controls sharpness of transfer function</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softPlus</span> <span class="o">=</span> <span class="n">SoftPlus</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createSoftPlus</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SoftShrink">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SoftShrink</code><span class="sig-paren">(</span><em>the_lambda=0.5</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SoftShrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SoftShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply the soft shrinkage function element-wise to the input Tensor</p>
<p>SoftShrinkage operator:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       <span class="o">|</span> <span class="n">x</span> <span class="o">-</span> <span class="k">lambda</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span>  <span class="k">lambda</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="k">lambda</span><span class="p">,</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="k">lambda</span>
       <span class="o">|</span> <span class="mi">0</span><span class="p">,</span> <span class="n">otherwise</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>the_lambda</strong> &#8211; lambda, default is 0.5</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softShrink</span> <span class="o">=</span> <span class="n">SoftShrink</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">)</span>
<span class="go">creating: createSoftShrink</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SoftSign">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SoftSign</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SoftSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SoftSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply SoftSign function to an n-dimensional input Tensor.</p>
<p>SoftSign function: f_i(x) = x_i / (1+|x_i|)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">softSign</span> <span class="o">=</span> <span class="n">SoftSign</span><span class="p">()</span>
<span class="go">creating: createSoftSign</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialAveragePooling">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialAveragePooling</code><span class="sig-paren">(</span><em>kw</em>, <em>kh</em>, <em>dw=1</em>, <em>dh=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>ceil_mode=False</em>, <em>count_include_pad=True</em>, <em>divide=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialAveragePooling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialAveragePooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies 2D average-pooling operation in kWxkH regions by step size dWxdH steps.
The number of output features is equal to the number of input planes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kW</strong> &#8211; kernel width</li>
<li><strong>kH</strong> &#8211; kernel height</li>
<li><strong>dW</strong> &#8211; step width</li>
<li><strong>dH</strong> &#8211; step height</li>
<li><strong>padW</strong> &#8211; padding width</li>
<li><strong>padH</strong> &#8211; padding height</li>
<li><strong>ceilMode</strong> &#8211; whether the output size is to be ceiled or floored</li>
<li><strong>countIncludePad</strong> &#8211; whether to include padding when dividing thenumber of elements in pooling region</li>
<li><strong>divide</strong> &#8211; whether to do the averaging</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialAveragePooling</span> <span class="o">=</span> <span class="n">SpatialAveragePooling</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="go">creating: createSpatialAveragePooling</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialBatchNormalization">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialBatchNormalization</code><span class="sig-paren">(</span><em>n_output</em>, <em>eps=1e-05</em>, <em>momentum=0.1</em>, <em>affine=True</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialBatchNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialBatchNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This file implements Batch Normalization as described in the paper:
&#8220;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&#8221;
by Sergey Ioffe, Christian Szegedy
This implementation is useful for inputs coming from convolution layers.
For non-convolutional layers, see [[BatchNormalization]]
The operation implemented is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>      <span class="p">(</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">--------------------</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">+</span> <span class="n">beta</span>
   <span class="n">standard</span><span class="o">-</span><span class="n">deviation</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>where gamma and beta are learnable parameters.
The learning of gamma and beta is optional.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialBatchNormalization</span> <span class="o">=</span> <span class="n">SpatialBatchNormalization</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSpatialBatchNormalization</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialContrastiveNormalization">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialContrastiveNormalization</code><span class="sig-paren">(</span><em>n_input_plane=1</em>, <em>kernel=None</em>, <em>threshold=0.0001</em>, <em>thresval=0.0001</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialContrastiveNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialContrastiveNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Subtractive + divisive contrast normalization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_input_plane</strong> &#8211; </li>
<li><strong>kernel</strong> &#8211; </li>
<li><strong>threshold</strong> &#8211; </li>
<li><strong>thresval</strong> &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialContrastiveNormalization</span> <span class="o">=</span> <span class="n">SpatialContrastiveNormalization</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
<span class="go">creating: createSpatialContrastiveNormalization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialContrastiveNormalization</span> <span class="o">=</span> <span class="n">SpatialContrastiveNormalization</span><span class="p">()</span>
<span class="go">creating: createSpatialContrastiveNormalization</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialConvolution">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialConvolution</code><span class="sig-paren">(</span><em>n_input_plane</em>, <em>n_output_plane</em>, <em>kernel_w</em>, <em>kernel_h</em>, <em>stride_w=1</em>, <em>stride_h=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>n_group=1</em>, <em>propagate_back=True</em>, <em>init_method='default'</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a 2D convolution over an input image composed of several input planes.
The input tensor in forward(input) is expected to be
a 3D tensor (nInputPlane x height x width).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_input_plane</strong> &#8211; The number of expected input planes in the image given into forward()</li>
<li><strong>n_output_plane</strong> &#8211; The number of output planes the convolution layer will produce.</li>
<li><strong>kernel_w</strong> &#8211; The kernel width of the convolution</li>
<li><strong>kernel_h</strong> &#8211; The kernel height of the convolution</li>
<li><strong>stride_w</strong> &#8211; The step of the convolution in the width dimension.</li>
<li><strong>stride_h</strong> &#8211; The step of the convolution in the height dimension</li>
<li><strong>pad_w</strong> &#8211; The additional zeros added per width to the input planes.</li>
<li><strong>pad_h</strong> &#8211; The additional zeros added per height to the input planes.</li>
<li><strong>n_group</strong> &#8211; Kernel group number</li>
<li><strong>propagate_back</strong> &#8211; Propagate gradient back</li>
<li><strong>init_method</strong> &#8211; Initialization method to initialize bias and weight</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialConvolution</span> <span class="o">=</span> <span class="n">SpatialConvolution</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">creating: createSpatialConvolution</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialConvolutionMap">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialConvolutionMap</code><span class="sig-paren">(</span><em>conn_table</em>, <em>kw</em>, <em>kh</em>, <em>dw=1</em>, <em>dh=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialConvolutionMap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialConvolutionMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This class is a generalization of SpatialConvolution.
It uses a generic connection table between input and output features.
The SpatialConvolution is equivalent to using a full connection table.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialConvolutionMap</span> <span class="o">=</span> <span class="n">SpatialConvolutionMap</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="go">creating: createSpatialConvolutionMap</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialCrossMapLRN">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialCrossMapLRN</code><span class="sig-paren">(</span><em>size=5</em>, <em>alpha=1.0</em>, <em>beta=0.75</em>, <em>k=1.0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialCrossMapLRN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialCrossMapLRN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies Spatial Local Response Normalization between different feature maps.
The operation implemented is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>                             <span class="n">x_f</span>
<span class="n">y_f</span> <span class="o">=</span>  <span class="o">-------------------------------------------------</span>
        <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="n">size</span><span class="p">)</span><span class="o">*</span> <span class="n">sum_</span><span class="p">{</span><span class="n">l</span><span class="o">=</span><span class="n">l1</span> <span class="n">to</span> <span class="n">l2</span><span class="p">}</span> <span class="p">(</span><span class="n">x_l</span><span class="o">^</span><span class="mi">2</span><span class="o">^</span><span class="p">))</span><span class="o">^</span><span class="n">beta</span><span class="o">^</span>
</pre></div>
</div>
<p>where x_f is the input at spatial locations h,w (not shown for simplicity) and feature map f,
l1 corresponds to max(0,f-ceil(size/2)) and l2 to min(F, f-ceil(size/2) + size).
Here, F is the number of feature maps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> &#8211; the number of channels to sum over (for cross channel LRN) or the side length ofthe square region to sum over (for within channel LRN)</li>
<li><strong>alpha</strong> &#8211; the scaling parameter</li>
<li><strong>beta</strong> &#8211; the exponent</li>
<li><strong>k</strong> &#8211; a constant</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialCrossMapLRN</span> <span class="o">=</span> <span class="n">SpatialCrossMapLRN</span><span class="p">()</span>
<span class="go">creating: createSpatialCrossMapLRN</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialDilatedConvolution">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialDilatedConvolution</code><span class="sig-paren">(</span><em>n_input_plane</em>, <em>n_output_plane</em>, <em>kw</em>, <em>kh</em>, <em>dw=1</em>, <em>dh=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>dilation_w=1</em>, <em>dilation_h=1</em>, <em>init_method='default'</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialDilatedConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialDilatedConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply a 2D dilated convolution over an input image.</p>
<p>The input tensor is expected to be a 3D or 4D(with batch) tensor.</p>
<p>If input is a 3D tensor nInputPlane x height x width,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">owidth</span>  <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">padW</span> <span class="o">-</span> <span class="n">dilationW</span> <span class="o">*</span> <span class="p">(</span><span class="n">kW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">dW</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">oheight</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">padH</span> <span class="o">-</span> <span class="n">dilationH</span> <span class="o">*</span> <span class="p">(</span><span class="n">kH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">dH</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Reference Paper: Yu F, Koltun V. Multi-scale context aggregation by dilated convolutions[J].
arXiv preprint arXiv:1511.07122, 2015.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_input_plane</strong> &#8211; The number of expected input planes in the image given into forward().</li>
<li><strong>n_output_plane</strong> &#8211; The number of output planes the convolution layer will produce.</li>
<li><strong>kw</strong> &#8211; The kernel width of the convolution.</li>
<li><strong>kh</strong> &#8211; The kernel height of the convolution.</li>
<li><strong>dw</strong> &#8211; The step of the convolution in the width dimension. Default is 1.</li>
<li><strong>dh</strong> &#8211; The step of the convolution in the height dimension. Default is 1.</li>
<li><strong>pad_w</strong> &#8211; The additional zeros added per width to the input planes. Default is 0.</li>
<li><strong>pad_h</strong> &#8211; The additional zeros added per height to the input planes. Default is 0.</li>
<li><strong>dilation_w</strong> &#8211; The number of pixels to skip. Default is 1.</li>
<li><strong>dilation_h</strong> &#8211; The number of pixels to skip. Default is 1.</li>
<li><strong>init_method</strong> &#8211; Init method, Default, Xavier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialDilatedConvolution</span> <span class="o">=</span> <span class="n">SpatialDilatedConvolution</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSpatialDilatedConvolution</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialDivisiveNormalization">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialDivisiveNormalization</code><span class="sig-paren">(</span><em>n_input_plane=1</em>, <em>kernel=None</em>, <em>threshold=0.0001</em>, <em>thresval=0.0001</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialDivisiveNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialDivisiveNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a spatial division operation on a series of 2D inputs using kernel for
computing the weighted average in a neighborhood. The neighborhood is defined for
a local spatial region that is the size as kernel and across all features. For
an input image, since there is only one feature, the region is only spatial. For
an RGB image, the weighted average is taken over RGB channels and a spatial region.</p>
<p>If the kernel is 1D, then it will be used for constructing and separable 2D kernel.
The operations will be much more efficient in this case.</p>
<p>The kernel is generally chosen as a gaussian when it is believed that the correlation
of two pixel locations decrease with increasing distance. On the feature dimension,
a uniform average is used since the weighting across features is not known.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nInputPlane</strong> &#8211; number of input plane, default is 1.</li>
<li><strong>kernel</strong> &#8211; kernel tensor, default is a 9 x 9 tensor.</li>
<li><strong>threshold</strong> &#8211; threshold</li>
<li><strong>thresval</strong> &#8211; threshhold value to replace withif data is smaller than theshold</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialDivisiveNormalization</span> <span class="o">=</span> <span class="n">SpatialDivisiveNormalization</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">kernel</span><span class="p">)</span>
<span class="go">creating: createSpatialDivisiveNormalization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialDivisiveNormalization</span> <span class="o">=</span> <span class="n">SpatialDivisiveNormalization</span><span class="p">()</span>
<span class="go">creating: createSpatialDivisiveNormalization</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialFullConvolution">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialFullConvolution</code><span class="sig-paren">(</span><em>n_input_plane</em>, <em>n_output_plane</em>, <em>kw</em>, <em>kh</em>, <em>dw=1</em>, <em>dh=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>adj_w=0</em>, <em>adj_h=0</em>, <em>n_group=1</em>, <em>no_bias=False</em>, <em>init_method='default'</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialFullConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialFullConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply a 2D full convolution over an input image.
The input tensor is expected to be a 3D or 4D(with batch) tensor. Note that instead
of setting adjW and adjH, SpatialFullConvolution[Table, T] also accepts a table input
with two tensors: T(convInput, sizeTensor) where convInput is the standard input tensor,
and the size of sizeTensor is used to set the size of the output (will ignore the adjW and
adjH values used to construct the module). This module can be used without a bias by setting
parameter noBias = true while constructing the module.</p>
<p>If input is a 3D tensor nInputPlane x height x width,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">owidth</span>  <span class="o">=</span> <span class="p">(</span><span class="n">width</span>  <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">padW</span> <span class="o">+</span> <span class="n">kW</span> <span class="o">+</span> <span class="n">adjW</span>
<span class="n">oheight</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dH</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">padH</span> <span class="o">+</span> <span class="n">kH</span> <span class="o">+</span> <span class="n">adjH</span>
</pre></div>
</div>
<p>Other frameworks call this operation &#8220;In-network Upsampling&#8221;, &#8220;Fractionally-strided convolution&#8221;,
&#8220;Backwards Convolution,&#8221; &#8220;Deconvolution&#8221;, or &#8220;Upconvolution.&#8221;</p>
<p>Reference Paper: Long J, Shelhamer E, Darrell T. Fully convolutional networks for semantic
segmentation[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.
2015: 3431-3440.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nInputPlane</strong> &#8211; The number of expected input planes in the image given into forward()</li>
<li><strong>nOutputPlane</strong> &#8211; The number of output planes the convolution layer will produce.</li>
<li><strong>kW</strong> &#8211; The kernel width of the convolution.</li>
<li><strong>kH</strong> &#8211; The kernel height of the convolution.</li>
<li><strong>dW</strong> &#8211; The step of the convolution in the width dimension. Default is 1.</li>
<li><strong>dH</strong> &#8211; The step of the convolution in the height dimension. Default is 1.</li>
<li><strong>padW</strong> &#8211; The additional zeros added per width to the input planes. Default is 0.</li>
<li><strong>padH</strong> &#8211; The additional zeros added per height to the input planes. Default is 0.</li>
<li><strong>adjW</strong> &#8211; Extra width to add to the output image. Default is 0.</li>
<li><strong>adjH</strong> &#8211; Extra height to add to the output image. Default is 0.</li>
<li><strong>nGroup</strong> &#8211; Kernel group number.</li>
<li><strong>noBias</strong> &#8211; If bias is needed.</li>
<li><strong>initMethod</strong> &#8211; Init method, Default, Xavier, Bilinear.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialFullConvolution</span> <span class="o">=</span> <span class="n">SpatialFullConvolution</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSpatialFullConvolution</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialMaxPooling">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialMaxPooling</code><span class="sig-paren">(</span><em>kw</em>, <em>kh</em>, <em>dw</em>, <em>dh</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>to_ceil=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialMaxPooling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialMaxPooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies 2D max-pooling operation in kWxkH regions by step size dWxdH steps.
The number of output features is equal to the number of input planes.
If the input image is a 3D tensor nInputPlane x height x width,
the output image size will be nOutputPlane x oheight x owidth where</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">owidth</span>  <span class="o">=</span> <span class="n">op</span><span class="p">((</span><span class="n">width</span>  <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">padW</span> <span class="o">-</span> <span class="n">kW</span><span class="p">)</span> <span class="o">/</span> <span class="n">dW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">oheight</span> <span class="o">=</span> <span class="n">op</span><span class="p">((</span><span class="n">height</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">padH</span> <span class="o">-</span> <span class="n">kH</span><span class="p">)</span> <span class="o">/</span> <span class="n">dH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>op is a rounding operator. By default, it is floor.
It can be changed by calling :ceil() or :floor() methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kW</strong> &#8211; kernel width</li>
<li><strong>kH</strong> &#8211; kernel height</li>
<li><strong>dW</strong> &#8211; step size in width</li>
<li><strong>dH</strong> &#8211; step size in height</li>
<li><strong>padW</strong> &#8211; padding in width</li>
<li><strong>padH</strong> &#8211; padding in height</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialMaxPooling</span> <span class="o">=</span> <span class="n">SpatialMaxPooling</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">creating: createSpatialMaxPooling</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialShareConvolution">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialShareConvolution</code><span class="sig-paren">(</span><em>n_input_plane</em>, <em>n_output_plane</em>, <em>kernel_w</em>, <em>kernel_h</em>, <em>stride_w=1</em>, <em>stride_h=1</em>, <em>pad_w=0</em>, <em>pad_h=0</em>, <em>n_group=1</em>, <em>propagate_back=True</em>, <em>init_method='default'</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialShareConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialShareConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialShareConvolution</span> <span class="o">=</span> <span class="n">SpatialShareConvolution</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSpatialShareConvolution</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialSubtractiveNormalization">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialSubtractiveNormalization</code><span class="sig-paren">(</span><em>n_input_plane=1</em>, <em>kernel=None</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialSubtractiveNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialSubtractiveNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies a spatial subtraction operation on a series of 2D inputs using kernel for
computing the weighted average in a neighborhood. The neighborhood is defined for
a local spatial region that is the size as kernel and across all features. For a
an input image, since there is only one feature, the region is only spatial. For
an RGB image, the weighted average is taken over RGB channels and a spatial region.</p>
<p>If the kernel is 1D, then it will be used for constructing and separable 2D kernel.
The operations will be much more efficient in this case.</p>
<p>The kernel is generally chosen as a gaussian when it is believed that the correlation
of two pixel locations decrease with increasing distance. On the feature dimension,
a uniform average is used since the weighting across features is not known.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n_input_plane</strong> &#8211; number of input plane, default is 1.</li>
<li><strong>kernel</strong> &#8211; kernel tensor, default is a 9 x 9 tensor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialSubtractiveNormalization</span> <span class="o">=</span> <span class="n">SpatialSubtractiveNormalization</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">kernel</span><span class="p">)</span>
<span class="go">creating: createSpatialSubtractiveNormalization</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialSubtractiveNormalization</span> <span class="o">=</span> <span class="n">SpatialSubtractiveNormalization</span><span class="p">()</span>
<span class="go">creating: createSpatialSubtractiveNormalization</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SpatialZeroPadding">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SpatialZeroPadding</code><span class="sig-paren">(</span><em>pad_left</em>, <em>pad_right</em>, <em>pad_top</em>, <em>pad_bottom</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SpatialZeroPadding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SpatialZeroPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Each feature map of a given input is padded with specified number of zeros.
If padding values are negative, then input is cropped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>padLeft</strong> &#8211; pad left position</li>
<li><strong>padRight</strong> &#8211; pad right position</li>
<li><strong>padTop</strong> &#8211; pad top position</li>
<li><strong>padBottom</strong> &#8211; pad bottom position</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spatialZeroPadding</span> <span class="o">=</span> <span class="n">SpatialZeroPadding</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSpatialZeroPadding</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.SplitTable">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">SplitTable</code><span class="sig-paren">(</span><em>dimension</em>, <em>n_input_dims=-1</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#SplitTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.SplitTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Creates a module that takes a Tensor as input and
outputs several tables, splitting the Tensor along
the specified dimension <cite>dimension</cite>.</p>
<p>The input to this layer is expected to be a tensor, or a batch of tensors;
when using mini-batch, a batch of sample tensors will be passed to the layer and
the user need to specify the number of dimensions of each sample tensor in a
batch using <cite>nInputDims</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; to be split along this dimension</li>
<li><strong>n_input_dims</strong> &#8211; specify the number of dimensions that this module will receiveIf it is more than the dimension of input tensors, the first dimensionwould be considered as batch size</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">splitTable</span> <span class="o">=</span> <span class="n">SplitTable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSplitTable</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Sqrt">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Sqrt</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Sqrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply an element-wise sqrt operation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">Sqrt</span><span class="p">()</span>
<span class="go">creating: createSqrt</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Square">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Square</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Square" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Apply an element-wise square operation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">Square</span><span class="p">()</span>
<span class="go">creating: createSquare</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Squeeze">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Squeeze</code><span class="sig-paren">(</span><em>dim</em>, <em>num_input_dims=-2147483648</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Delete singleton all dimensions or a specific dim.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> &#8211; Optional. The dimension to be delete. Default: delete all dimensions.</li>
<li><strong>num_input_dims</strong> &#8211; Optional. If in a batch model, set to the inputDims.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span> <span class="o">=</span> <span class="n">Squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createSqueeze</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Sum">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Sum</code><span class="sig-paren">(</span><em>dimension=1</em>, <em>n_input_dims=-1</em>, <em>size_average=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>It is a simple layer which applies a sum operation over the given dimension.
When nInputDims is provided, the input will be considered as a batches.
Then the sum operation will be applied in (dimension + 1)
The input to this layer is expected to be a tensor, or a batch of tensors;
when using mini-batch, a batch of sample tensors will be passed to the layer and
the user need to specify the number of dimensions of each sample tensor in the
batch using <cite>nInputDims</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; the dimension to be applied sum operation</li>
<li><strong>n_input_dims</strong> &#8211; specify the number of dimensions that this module will receiveIf it is more than the dimension of input tensors, the first dimensionwould be considered as batch size</li>
<li><strong>size_average</strong> &#8211; default is false, if it is true, it will return the mean instead</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span> <span class="o">=</span> <span class="n">Sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createSum</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Tanh">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Tanh</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Tanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Applies the Tanh function element-wise to the input Tensor, thus outputting a Tensor of the same
dimension. Tanh is defined as f(x) = (exp(x)-exp(-x))/(exp(x)+exp(-x)).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tanh</span> <span class="o">=</span> <span class="n">Tanh</span><span class="p">()</span>
<span class="go">creating: createTanh</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.TanhShrink">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">TanhShrink</code><span class="sig-paren">(</span><em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#TanhShrink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.TanhShrink" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>A simple layer for each element of the input tensor, do the following operation
during the forward process:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tanhShrink</span> <span class="o">=</span> <span class="n">TanhShrink</span><span class="p">()</span>
<span class="go">creating: createTanhShrink</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Threshold">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Threshold</code><span class="sig-paren">(</span><em>th=1e-06</em>, <em>v=0.0</em>, <em>ip=False</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Threshold input Tensor.
If values in the Tensor smaller than th, then replace it with v</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>th</strong> &#8211; the threshold to compare with</li>
<li><strong>v</strong> &#8211; the value to replace with</li>
<li><strong>ip</strong> &#8211; inplace mode</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">threshold</span> <span class="o">=</span> <span class="n">Threshold</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">creating: createThreshold</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.TimeDistributed">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">TimeDistributed</code><span class="sig-paren">(</span><em>model</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#TimeDistributed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.TimeDistributed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This layer is intended to apply contained layer to each temporal time slice
of input tensor.</p>
<p>For instance, The TimeDistributed Layer can feed each time slice of input tensor
to the Linear layer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">td</span> <span class="o">=</span> <span class="n">TimeDistributed</span><span class="p">(</span><span class="n">Linear</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">creating: createLinear</span>
<span class="go">creating: createTimeDistributed</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Transpose">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Transpose</code><span class="sig-paren">(</span><em>permutations</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Transpose input along specified dimensions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>permutations</strong> &#8211; dimension pairs that need to swap</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span> <span class="o">=</span> <span class="n">Transpose</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="go">creating: createTranspose</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.Unsqueeze">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">Unsqueeze</code><span class="sig-paren">(</span><em>pos</em>, <em>num_input_dims=-2147483648</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#Unsqueeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.Unsqueeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>Create an Unsqueeze layer.  Insert singleton dim (i.e., dimension 1) at position pos.
For an input with dim = input.dim(),
there are dim + 1 possible positions to insert the singleton dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> &#8211; The position will be insert singleton.</li>
<li><strong>num_input_dims</strong> &#8211; Optional. If in a batch model, set to the inputDim</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unsqueeze</span> <span class="o">=</span> <span class="n">Unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">creating: createUnsqueeze</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nn.layer.View">
<em class="property">class </em><code class="descclassname">nn.layer.</code><code class="descname">View</code><span class="sig-paren">(</span><em>sizes</em>, <em>num_input_dims=0</em>, <em>bigdl_type='float'</em><span class="sig-paren">)</span><a class="reference internal" href="modules/nn/layer.html#View"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nn.layer.View" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nn.layer.Model" title="nn.layer.Model"><code class="xref py py-class docutils literal"><span class="pre">nn.layer.Model</span></code></a></p>
<p>This module creates a new view of the input tensor using the sizes passed to the constructor.
The method setNumInputDims() allows to specify the expected number of dimensions of the
inputs of the modules. This makes it possible to use minibatch inputs when using a size -1
for one of the dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; sizes use for creates a new view</td>
</tr>
</tbody>
</table>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">View</span><span class="p">([</span><span class="mi">1024</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">creating: createView</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-nn">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nn" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="optim.html" title="optim package"
             >next</a></li>
        <li class="right" >
          <a href="models.lenet.html" title="models.lenet package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PySpark master documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
  </body>
</html>